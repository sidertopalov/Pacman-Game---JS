<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Pacman!</title>
        <script src="//cdn.jsdelivr.net/phaser/2.5.0/phaser.min.js"></script>
        <script src="map.js"></script>
        <script src="Node.js"></script>
        <script src="NodeState.js"></script>
        <script src="SearchParameters.js"></script>
        <script src="PathFinder.js"></script>
        <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            /*background: url("http://www.3dhdwallpapers.com/image.php?width=700&height=700&cropratio=2:1&image=/wallpapers/171120153/abstract-hacker-wallpaper-images.jpg") no-repeat;
            background-size: cover;*/
        }
    </style>
    </head>
    <body>

    <script type="text/javascript">

    window.onload = function() {

        //  Note that this html file is set to pull down Phaser 2.5.0 from the JS Delivr CDN.
        //  Although it will work fine with this tutorial, it's almost certainly not the most current version.
        //  Be sure to replace it with an updated version before you start experimenting with adding your own code.
        // 448, 496

        class pacmanGhosts {

            constructor (obj, currentMove, lastMove) {
                this.obj = obj;
                this.currentMove = currentMove;
                this.lastMove = lastMove;
            }
            moveGhost(dir) {
                
                this.dir = dir;
                // console.log(this.dir);
                if (this.currentMove === Phaser.LEFT) {
                    this.obj.body.velocity.x -= 50;
                }
                else if (this.currentMove === Phaser.RIGHT) {
                    this.obj.body.velocity.x += 50;
                }
                else if (this.currentMove === Phaser.UP) {
                    this.obj.body.velocity.y -= 50;
                }
                else if (this.currentMove === Phaser.DOWN) {
                    this.obj.body.velocity.y += 50;
                }
                this.lastMove = this.currentMove;
                this.currentMove = dir;
                // console.log(dir);
            }

            checkDir(){
                var randomNum = game.rnd.integerInRange(1,1000);
                // console.log(this.direc);
                if (randomNum >= 1 && randomNum <= 250 && this.lastMove != Phaser.LEFT) 
                {   
                    // this.wrong = Phaser.LEFT;
                    this.moveGhost(Phaser.LEFT);
                } 
                else if (randomNum >= 251 && randomNum <= 500 && this.lastMove != Phaser.RIGHT)
                {
                    // this.wrong = Phaser.RIGHT;
                    this.moveGhost(Phaser.RIGHT);
                }
                else if (randomNum >= 501 && randomNum <= 750 && this.lastMove != Phaser.UP ) 
                {
                    // this.wrong = Phaser.UP;
                    this.moveGhost(Phaser.UP);
                }
                else if (randomNum >= 751 && this.lastMove != Phaser.DOWN) 
                {
                    // this.wrong = Phaser.DOWN;
                    this.moveGhost(Phaser.DOWN);
                }
                else {
                    this.checkDir();
                }
            }
        }

        var game = new Phaser.Game(448, 496, Phaser.AUTO, 'phaser-example', { preload: preload, create: create, update: update, render: render });

        function preload() {
            game.load.tilemap('map', 'assets/pacman-map.json', null, Phaser.Tilemap.TILED_JSON);
            game.load.image('dot', 'assets/dot.png');
            game.load.image('tiles', 'assets/pacman-tiles.png');
            game.load.spritesheet('pacman', 'assets/pacman.png', 32, 32);
            game.load.spritesheet('redGhost', 'assets/red.png', 39, 40, 8, null, 1);
            game.load.spritesheet('greenGhost', 'assets/red.png', 39, 40, 8, null, 1);
            game.load.spritesheet('yellowGhost', 'assets/red.png', 39, 40, 8, null, 1);
            game.load.spritesheet('pinkyGhost', 'assets/red.png', 39, 40, 8, null, 1);

            game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
            game.scale.pageAlignHorizontally = true;
            game.scale.pageAlignVertically = true;
            Phaser.Canvas.setImageRenderingCrisp(game.canvas);
            game.physics.startSystem(Phaser.Physics.ARCADE);
        }

        var map = null;
        var layer = null;
        var pacman = null;

        var safetile = 14;
        var gridsize = 16;

        var speed = 70;
        var threshold = 3;

        var marker = new Phaser.Point();
        var turnPoint = new Phaser.Point();

        var directions = [ null, null, null, null, null ];
        var opposites = [ Phaser.NONE, Phaser.RIGHT, Phaser.LEFT, Phaser.DOWN, Phaser.UP ];
        // var opposites = [ Phaser.Keyboard.NONE, Phaser.Keyboard.RIGHT, Phaser.Keyboard.LEFT, Phaser.Keyboard.DOWN, Phaser.Keyboard.UP ];

        var current = Phaser.Keyboard.NONE;
        var turning = Phaser.Keyboard.NONE;

        //Information about game (Score,Level,Pacman Life, etc..)
        var score = 0;
        var level = 1;
        var scoreText;
        var levelText;
        var speedText;
        var pacmanLife = 3;
        var pacmanLifeText;

        // Pacman Ghosts
        var blinky;
        var blinkyInst;
        var green;
        var greenInst;
        var yellow;
        var yellowInst;
        var pinky;
        var pinkyInst;

        var timeJump = 0;
        var flag =  true;
        var paths;
        var blinkyLocation;
        var pacmanLocation;
        var newMap;

        var step = 0;
        var pacmanPrevX;
        var pacmanPrevY;


        function create() {

            map = game.add.tilemap('map');
            map.addTilesetImage('pacman-tiles', 'tiles');
            // console.log(map);
            layer = map.createLayer('Pacman');
            layer.debug = 1;

            dots = game.add.physicsGroup();

            map.createFromTiles(7, safetile, 'dot', layer, dots);

            dots.setAll('x', 6, false, false, 1);
            dots.setAll('y', 6, false, false, 1);

            map.setCollisionByExclusion([safetile], true, layer);
            // Pacman settings
            pacman = game.add.sprite((23 * 16) + 8, (26 * 16) + 8, 'pacman', 0);
            pacman.anchor.set(0.5);
            pacman.animations.add('munch', [0, 1, 2, 1], 20, true);

            game.physics.arcade.enable(pacman);
            pacman.body.setSize(16, 16, 8, 8);

            cursors = game.input.keyboard.createCursorKeys();

            levelText = game.add.text(1, 165, 'Level: 1', {fontSize: '14px', fill: '#FDCC91'});
            scoreText = game.add.text(0, 185, 'Score: 0', {fontSize: '14px', fill: '#FFB700'});
            pacmanLifeText = game.add.text(370, 165, 'Life: 3', {fontSize: '14px', fill: '#FDCC91'});

            //Ghosts settings
            blinky = game.add.sprite((25 * 16) + 8, (26 * 16) + 8, 'redGhost');
            // green = game.add.sprite(448/2 - 40, 496/2-62, 'greenGhost');
            // yellow = game.add.sprite(448/2 + 40, 496/2-62, 'yellowGhost');
            // pinky = game.add.sprite(27, 27, 'pinkyGhost');

            blinky.anchor.set(0.5);
            // green.anchor.set(0.5);
            // yellow.anchor.set(0.5);
            // pinky.anchor.set(0.5);

            blinky.animations.add('blinky', [0, 1, 2, 3, 4, 5], 20, true);
            // green.animations.add('green', [0, 1, 2, 3, 4, 5, 6], 10, true);
            // yellow.animations.add('yellow', [0, 1, 2, 3, 4, 5, 6], 10, true);
            // pinky.animations.add('pinky', [0, 1, 2, 3, 4, 5, 6], 10, true);

            game.physics.arcade.enable(blinky);
            // game.physics.arcade.enable(green);
            // game.physics.arcade.enable(yellow);
            // game.physics.arcade.enable(pinky);

            blinky.scale.setTo(0.7,0.7);
            // green.scale.setTo(0.7, 0.7);
            // yellow.scale.setTo(0.7, 0.7);
            // pinky.scale.setTo(0.7, 0.7);

            blinky.animations.play('blinky', 5, true);
            // green.animations.play('green', 5, true);
            // yellow.animations.play('yellow', 5, true);
            // pinky.animations.play('pinky', 5, true);

            blinky.body.setSize(18.5, 18.5, 8.5, 12);
            // green.body.setSize(22.5, 22.5, 8, 8);
            // yellow.body.setSize(22.5, 22.5, 8, 8);
            // pinky.body.setSize(22.5, 22.5, 8, 8);
            
            blinkyInst = new pacmanGhosts(blinky, null, null);
            // greenInst = new pacmanGhosts(green, null, null);
            // yellowInst = new pacmanGhosts(yellow, null, null);
            // pinkyInst = new pacmanGhosts(pinky, null, null);

            //A star (AI enemy implementation)

            // console.log(blinky);

            blinkyLocation = map.getTileWorldXY(blinky.x, blinky.y);
            pacmanLocation = map.getTileWorldXY(pacman.x, pacman.y);
            var InitializeMap = new Map(map.layer.data);
            newMap = InitializeMap.getMap();
            var startLocation = new Phaser.Point(blinkyLocation.y, blinkyLocation.x);
            var endLocation = new Phaser.Point(pacmanLocation.y, pacmanLocation.x);
            var searchParameters = new SearchParameters(startLocation, endLocation, newMap);
            var pathFinder = new PathFinder(searchParameters);
            paths = pathFinder.FindPath();

            pacmanPrevX = pacman.x;
            pacmanPrevY = pacman.y;

            console.log(paths);
            // var nodesArr = pathFinder.InitializeNodes(newMap);
            // console.log(paths);
            
            // console.log(nodesArr[blinkyLocation.y][blinkyLocation.x-1]);
            // console.log(nodesArr[blinkyLocation.y][blinkyLocation.x-2]);
            // console.log(newMap[pacmanLocation.y][pacmanLocation.x]);
            // console.log(blinkyLocation);
            // console.log(pacmanLocation);
            // for (var y = 0; y < newMap.length; y++) {
            //     for (var x = 0; x < newMap[0].length; x++) {
            //         if (nodesArr[y][x].IsWalkable == true) 
            //         {
            //             document.write(" * ");
            //         }
            //         else 
            //         {
            //             document.write(" # ");
            //         }
            //         if (blinkyLocation.x == x && blinkyLocation.y == y) 
            //         {
            //             document.write(" S ");
            //         }
            //         // if (x == 14 && y == 11) 
            //         // {
            //         //     document.write(" S ");
            //         // }
            //         if (pacmanLocation.x == x && pacmanLocation.y == y) 
            //         {
            //             document.write(" F ");
            //         }
            //     }
            //     document.write("<br>");
            // }

            // game.physics.arcade.moveToXY(blinky, 9, 13, 80);
            // console.log(searchParameters);
            // console.log(blinky.position);
            // console.log(blinkyLocation);
            // console.log(pacman);
            // console.log(map);
            // console.log(newMap);
            // console.log(paths);
            // for (var path in paths) 
            // {   
            //     // console.log(paths[path]);
            //     // while() 
            //     // {
            //         game.physics.arcade.moveToXY(blinky, paths[path].x, paths[path].y,80);
            //     // }
            // }
            // Points
            // var pnt = new Phaser.Point(5,5);
            // var pnt1 = new Phaser.Point(6,6);
            // var endLocation = new Phaser.Point(4,4);
            // var node = new Node(1, 1, true, endLocation);
            // var nodeOne = new Node(20, 20, true, endLocation);
            // var nodeTwo = new Node(3, 3, true, endLocation)
            // nodeOne.setParentNode(node);
            // nodeTwo.setParentNode(nodeOne);
            // console.log(node2);
            // console.log(Node.getTraversalCost(pnt, pnt1));

            // SearchParameters
            // var searchParameters = new SearchParameters(pnt, pnt1, newMap);
            // var pathFinder  = new PathFinder(searchParameters);
            // var path = pathFinder.Search(nodeOne);
            // console.log(path);
            // console.log(Node.getTraversalCost(pnt,pnt1));
            // console.log(pacman.body.x);
            // console.log(pacman.body.y);

            // get cordination on pacman(x,y) for tilemap
            // var currentLoc = map.getTileWorldXY(pacman.body.x,pacman.body.y);

            // console.log(currentLoc.x);
            // console.log(currentLoc.y);



            // console.log(map.layer.data[1][1].worldX);
            // console.log(map.layer.data[1][1].worldY);
            // console.log(map.layer.data[20][20].worldX);
            // console.log(map.layer.data[20][20].worldY);

            pacman.play('munch');
            movePacman(Phaser.LEFT);

        }
            

        function checkKeys() {

            if (cursors.left.isDown && current !== Phaser.LEFT)
            {
                checkDirection(Phaser.LEFT);
            }
            else if (cursors.right.isDown && current !== Phaser.RIGHT)
            {
                checkDirection(Phaser.RIGHT);
            }
            else if (cursors.up.isDown && current !== Phaser.UP)
            {
                checkDirection(Phaser.UP);
            }
            else if (cursors.down.isDown && current !== Phaser.DOWN)
            {
                checkDirection(Phaser.DOWN);
            }
            else
            {
                //  This forces them to hold the key down to turn the corner
                turning = Phaser.NONE;
            }

        }

        function checkDirection(turnTo) {
            // console.log(turnTo);
            if (turning === turnTo || directions[turnTo] === null || directions[turnTo].index !== safetile) 
            {
                //  Invalid direction if they're already set to turn that way
                //  Or there is no tile there, or the tile isn't index 1 (a floor tile)
                return;
            }

             //  Check if they want to turn around and can
            if (current === opposites[turnTo]) 
            {
                movePacman(turnTo);
            }
            else
            {
                turning = turnTo;

                turnPoint.x = (marker.x * gridsize) + (gridsize / 2);
                turnPoint.y = (marker.y * gridsize) + (gridsize / 2);
            }
        }

        function eatDot (pacman,dot) {
            // Remove the star from the screen
            dot.kill();

            score = score + 1;
            scoreText.text = 'Score: ' + score;
            levelText.text = 'Level: ' + level;
            // speedText.text = 'Speed: ' + speed;

            if (dots.total === 0)
            {
                score = score + 100;
                level = level + 1;
                dots.callAll('revive');
            }
        }

        function eatPacman (pacman,ghost) {
            if (pacmanLife === 1) {
                pacmanLife--;
                pacmanLifeText.text = 'Life: ' + pacmanLife;
                var gameOver = game.add.text((14 * 16) - 43,(17 * 16) - 50, "Game OVER!", {fontSize: '14px', fill: '#FDCC91'});  
                pacman.kill();

            }else{
                pacmanLife--;
                pacmanLifeText.text = 'Life: ' + pacmanLife;
                pacman.reset((14 * 16) + 8,(17 * 16) + 8);
            }
        }

         function update () {
            // console.log(map);
            game.physics.arcade.collide(pacman, layer);
            //game.physics.arcade.collide(blinky, layer);
            game.physics.arcade.collide(green, layer);
            game.physics.arcade.collide(yellow, layer);
            game.physics.arcade.collide(pinky, layer);
            game.physics.arcade.overlap(pacman, dots, eatDot, null, game);
            game.physics.arcade.overlap(pacman, blinky, eatPacman, null, game);
            game.physics.arcade.overlap(pacman, green, eatPacman, null, game);
            game.physics.arcade.overlap(pacman, yellow, eatPacman, null, game);
            game.physics.arcade.overlap(pacman, pinky, eatPacman, null, game);

            marker.x = game.math.snapToFloor(Math.floor(pacman.x), gridsize) / gridsize;
            marker.y = game.math.snapToFloor(Math.floor(pacman.y), gridsize) / gridsize;

            //  Update our grid sensors
            directions[1] = map.getTileLeft(layer.index, marker.x, marker.y);
            directions[2] = map.getTileRight(layer.index, marker.x, marker.y);
            directions[3] = map.getTileAbove(layer.index, marker.x, marker.y);
            directions[4] = map.getTileBelow(layer.index, marker.x, marker.y);

            checkKeys();

            if(turning !== Phaser.NONE){
                turn();
            }


            blinkyLocation = map.getTileWorldXY(blinky.x, blinky.y);
            pacmanLocation = map.getTileWorldXY(pacman.x, pacman.y);

            var startLocation = new Phaser.Point(blinkyLocation.y, blinkyLocation.x);
            var endLocation = new Phaser.Point(pacmanLocation.y, pacmanLocation.x);
            var searchParameters = new SearchParameters(startLocation, endLocation, newMap);
            var pathFinder = new PathFinder(searchParameters);

            var timeNow = game.time.time;
            if (timeNow > timeJump) {
                timeJump = timeNow + 1000;
            }

            var tileX = (paths[step].y * 16) + 8;
            var tileY = (paths[step].x * 16) + 8;
            var blinkyX = blinky.x;
            var blinkyY = blinky.y;
            var absX = Math.abs(tileX - blinkyX);
            var absY = Math.abs(tileY - blinkyY);

            var check = (pacman.x == pacmanPrevX) || (pacman.y == pacmanPrevY);
            if ( check ) 
            {
                if ( absX < 1.0 && absY < 1.0 )
                {
                    if ( (paths.length - 1 > 1) && (step < paths.length - 1) ) {
                        paths.shift();
                        step++;
                        if (step  == paths.length ) { step = paths.length - 1; }
                        console.log(paths.length);
                        console.log(step);
                    }
                    else
                    {
                        pacmanPrevX = pacman.x;
                        pacmanPrevY = pacman.y;
                        paths = pathFinder.FindPath();
                        step = 0;
                    }
                }
            }
            else 
            {
                pacmanPrevX = pacman.x;
                pacmanPrevY = pacman.y;
                paths = pathFinder.FindPath();
                step = 0;
                console.log(paths);

            }

            game.physics.arcade.moveToXY(blinky, tileX, tileY);

            // var tileX = (paths[step].y * 16) + 8;
            // var tileY = (paths[step].x * 16) + 8;
            // var blinkyX = blinky.x;
            // var blinkyY = blinky.y;
            // var absX = Math.abs(tileX - blinkyX);
            // var absY = Math.abs(tileY - blinkyY);

            // game.physics.arcade.moveToXY(blinky, tileX, tileY);

            // console.log("TileX: " + tileX,"TileY: " + tileY, 
            //         "BlinkyX: " + blinkyX,"BlinkyY: " + blinkyY,
            //         "PacmanX: " + pacman.x,"PacmanY: " + pacman.y,
            //         "AbsX: " + Math.abs(tileX - blinkyX), "AbsY: " + Math.abs(tileY - blinkyY));

            // if(game.physics.arcade.moveToXY(blinky, tileX, tileY))
            // {
            //     if (paths.length - 1 > 0) {
            //         console.log("Befor: " + tileX, tileY);
            //         paths.splice(0, 1);
            //         tileX = (paths[0].y * 16) + 8;
            //         tileY = (paths[0].x * 16) + 8;
            //         game.physics.arcade.moveToXY(blinky, tileX, tileY);
            //         console.log("After: " + tileX, tileY);
            //     }
            // }


            // if ( tileX <= blinkyX && absY <= 1 )  // left
            // {
            //     blinky.body.velocity.x -= 50;
            //     // step++;
            // }
            // else if ( tileX >= blinkyX && absY <= 1 ) // right
            // {
            //     blinky.body.velocity.x += 50;
            //     // step++;
            // }
            // else if ( absX <= 1 && tileY <= blinkyY ) // UP
            // {
            //     blinky.body.velocity.y -= 50;
            //     // step++;
            // }
            // else if ( absX <= 1 && tileY >= blinkyY ) // Down
            // {
            //     blinky.body.velocity.y += 50;
            //     // step++;
            // }
            // if (absX >= 0.0 && absX <= 2 && absY >= 0.0 && absY <= 2 )
            // {
            //     paths = pathFinder.FindPath();
            // }


            // var timeNow = game.time.time;
            // if (timeNow > timeJump) {
                // console.log('timer');
                // blinkyInst.checkDir();
                // yellowInst.checkDir();
                // greenInst.checkDir();
                // pinkyInst.checkDir();
                // timeJump = timeNow + 500;
                // console.log(game.physics.arcade.moveToXY(yellow, pacman.body.x, pacman.body.y, speed));
                // console.log(game.physics.arcade.distanceBetween(pacman, yellow));
                // console.log(game.physics.arcade.distanceToXY(green, pacman.x, pacman.y));
            // }
            // checkDirGhost(blinky);
            // checkDirGhost(yellow);
            // checkDirGhost(green);
            // checkDirGhost(pinky);

        }

        function checkDirGhost(obj) {

            var randomNum = game.rnd.integerInRange(1,400);
            // console.log(randomNum);
            if (randomNum >= 1 && randomNum <= 100) 
            {
                moveGhost(obj, Phaser.LEFT);
            } 
            else if (randomNum >= 101 && randomNum <= 200)
            {
                moveGhost(obj, Phaser.RIGHT);
            }
            else if (randomNum >= 201 && randomNum <= 300) 
            {
                moveGhost(obj, Phaser.UP);
            }
            else if (randomNum >= 301) {
                moveGhost(obj, Phaser.DOWN);
            }
        }

        function moveGhost(obj, dir) {
                
            // var dir = this.dir;
            // console.log(dir);
            if (dir === Phaser.LEFT) 
            {
                obj.body.velocity.x -= 5;
            }
            else if (dir === Phaser.RIGHT) 
            {
                obj.body.velocity.x += 5;
            }
            else if (dir === Phaser.UP) 
            {
                obj.body.velocity.y -= 5;
            }
            else if (dir === Phaser.DOWN) 
            {
                obj.body.velocity.y += 5;
            }
        }

        function turn () {

            var cx = Math.floor(pacman.x);
            var cy = Math.floor(pacman.y);
            

            //  This needs a threshold, because at high speeds you can't turn because the coordinates skip past
            if (!game.math.fuzzyEqual(cx, turnPoint.x, threshold) || !game.math.fuzzyEqual(cy, turnPoint.y, threshold))
            {
                return false;
            }

            //  Grid align before turning
            pacman.x = turnPoint.x;
            pacman.y = turnPoint.y;

            pacman.body.reset(turnPoint.x, turnPoint.y);

            movePacman(turning);

            turning = Phaser.NONE;

            return true;

        }

        function movePacman(direction) {

            pacman.scale.x = 1;
            pacman.angle = 0;
            
            // console.log(direction);

            if (direction === Phaser.LEFT) // Move to the left
            {
                pacman.scale.x = -1;
                pacman.body.velocity.x = -speed;
            }
            else if (direction === Phaser.UP) // Up
            {
                pacman.angle = 270;
                pacman.body.velocity.y = -speed;
            }
            else if (direction === Phaser.RIGHT) // Move to the right
            {
                pacman.body.velocity.x = speed;
            }
            else if(direction === Phaser.DOWN) // Down
            {
                pacman.angle = 90;
                pacman.body.velocity.y = speed;
            }

            current = direction;
        }

        function render() {
            game.debug.body(pacman);
            game.debug.body(blinky);
            // game.debug.body(green);
            // game.debug.body(yellow);
            // game.debug.body(pinky);
        }
    };

    </script>

    </body>
</html>